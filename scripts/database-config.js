#!/usr/bin/env node

/**
 * üóÑÔ∏è Database Configuration & Testing Tool
 * Database Agent Utility for Step 2
 */

const fs = require('fs');
const path = require('path');

class DatabaseConfigurationTool {
  constructor() {
    this.workspaceRoot = process.cwd();
    this.dataDir = path.join(this.workspaceRoot, 'data');
    this.dbPath = path.join(this.dataDir, 'mtg-investment.db');
  }

  async checkCurrentDatabase() {
    console.log('üîç DATABASE AGENT - Current Database Status');
    console.log('==========================================');
    
    try {
      if (fs.existsSync(this.dbPath)) {
        const stats = fs.statSync(this.dbPath);
        console.log('‚úÖ SQLite Database Found');
        console.log(`   üìç Location: ${this.dbPath}`);
        console.log(`   üìä Size: ${(stats.size / 1024).toFixed(2)} KB`);
        console.log(`   üìÖ Modified: ${stats.mtime.toISOString()}`);
        
        // Test database connectivity
        await this.testSQLiteConnection();
      } else {
        console.log('‚ùå SQLite Database Not Found');
        console.log(`   üìç Expected: ${this.dbPath}`);
        console.log('   üí° Run: npm run db:init to create');
      }
    } catch (error) {
      console.error('‚ùå Database check failed:', error.message);
    }
  }

  async testSQLiteConnection() {
    try {
      const { Database } = require('sqlite3');
      const db = new Database(this.dbPath);
      
      return new Promise((resolve, reject) => {
        db.get("SELECT COUNT(*) as count FROM sqlite_master WHERE type='table'", (err, row) => {
          if (err) {
            reject(err);
          } else {
            console.log(`   üóÇÔ∏è  Tables: ${row.count}`);
            console.log('   ‚úÖ Connection: Working');
            db.close();
            resolve(true);
          }
        });
      });
    } catch (error) {
      console.log('   ‚ùå Connection: Failed');
      console.log(`   üö® Error: ${error.message}`);
    }
  }

  async testPostgreSQLConnection(connectionString) {
    console.log('üêò Testing PostgreSQL Connection...');
    
    try {
      const { Client } = require('pg');
      const client = new Client({ connectionString });
      
      await client.connect();
      const result = await client.query('SELECT version()');
      console.log('‚úÖ PostgreSQL Connection: Working');
      console.log(`   üìã Version: ${result.rows[0].version}`);
      await client.end();
      return true;
    } catch (error) {
      console.log('‚ùå PostgreSQL Connection: Failed');
      console.log(`   üö® Error: ${error.message}`);
      return false;
    }
  }

  generateDockerCompose() {
    const dockerCompose = `version: "3.8"
services:
  postgres:
    image: postgres:15
    restart: unless-stopped
    environment:
      POSTGRES_DB: mtg_investment
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secure_password_change_this
      POSTGRES_INITDB_ARGS: "--encoding=UTF8"
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./database/init.sql:/docker-entrypoint-initdb.d/init.sql
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      postgres:
        condition: service_healthy
    environment:
      DATABASE_URL: postgresql://postgres:secure_password_change_this@postgres:5432/mtg_investment
      NODE_ENV: production
    volumes:
      - ./data:/app/data

volumes:
  postgres_data:
`;

    fs.writeFileSync(path.join(this.workspaceRoot, 'docker-compose.yml'), dockerCompose);
    console.log('‚úÖ docker-compose.yml created');
  }

  generatePostgreSQLInit() {
    const initSQL = `-- MTG Investment Database Schema
-- Generated by Database Agent

-- Create database and extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pg_trgm";

-- Cards table
CREATE TABLE IF NOT EXISTS cards (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    mtgjson_uuid VARCHAR(36) UNIQUE NOT NULL,
    name VARCHAR(255) NOT NULL,
    set_code VARCHAR(10) NOT NULL,
    collector_number VARCHAR(20) NOT NULL,
    rarity VARCHAR(20) NOT NULL,
    colors TEXT[],
    mana_cost VARCHAR(100),
    cmc INTEGER,
    type_line VARCHAR(255),
    oracle_text TEXT,
    power VARCHAR(10),
    toughness VARCHAR(10),
    loyalty VARCHAR(10),
    image_uris JSONB,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Prices table
CREATE TABLE IF NOT EXISTS prices (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    card_id UUID REFERENCES cards(id) ON DELETE CASCADE,
    price_date DATE NOT NULL,
    usd DECIMAL(10,2),
    usd_foil DECIMAL(10,2),
    eur DECIMAL(10,2),
    eur_foil DECIMAL(10,2),
    tix DECIMAL(10,2),
    source VARCHAR(50) DEFAULT 'mtgjson',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Users table
CREATE TABLE IF NOT EXISTS users (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    username VARCHAR(255) UNIQUE NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    role VARCHAR(20) DEFAULT 'user',
    preferences JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Transactions table
CREATE TABLE IF NOT EXISTS transactions (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID REFERENCES users(id) ON DELETE CASCADE,
    card_id UUID REFERENCES cards(id) ON DELETE RESTRICT,
    transaction_type VARCHAR(20) NOT NULL,
    quantity INTEGER NOT NULL,
    price_per_unit DECIMAL(10,2) NOT NULL,
    total_amount DECIMAL(10,2) NOT NULL,
    transaction_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    notes TEXT,
    metadata JSONB DEFAULT '{}'
);

-- Performance indexes
CREATE INDEX IF NOT EXISTS idx_cards_name_trgm ON cards USING gin(name gin_trgm_ops);
CREATE INDEX IF NOT EXISTS idx_cards_set_code ON cards(set_code);
CREATE INDEX IF NOT EXISTS idx_cards_uuid ON cards(mtgjson_uuid);
CREATE INDEX IF NOT EXISTS idx_prices_card_date ON prices(card_id, price_date);
CREATE INDEX IF NOT EXISTS idx_prices_date ON prices(price_date DESC);
CREATE INDEX IF NOT EXISTS idx_transactions_user ON transactions(user_id);
CREATE INDEX IF NOT EXISTS idx_transactions_card ON transactions(card_id);
CREATE INDEX IF NOT EXISTS idx_transactions_date ON transactions(transaction_date DESC);

-- Update timestamp function
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = CURRENT_TIMESTAMP;
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Update triggers
CREATE TRIGGER IF NOT EXISTS update_cards_updated_at 
    BEFORE UPDATE ON cards 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER IF NOT EXISTS update_users_updated_at 
    BEFORE UPDATE ON users 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- Create default admin user (change password in production!)
INSERT INTO users (username, email, password_hash, role) 
VALUES ('admin', 'admin@mtginvestment.com', '$2b$10$dummy.hash.change.in.production', 'admin')
ON CONFLICT (email) DO NOTHING;
`;

    const databaseDir = path.join(this.workspaceRoot, 'database');
    if (!fs.existsSync(databaseDir)) {
      fs.mkdirSync(databaseDir, { recursive: true });
    }

    fs.writeFileSync(path.join(databaseDir, 'init.sql'), initSQL);
    console.log('‚úÖ database/init.sql created');
  }

  printRecommendations() {
    console.log('');
    console.log('üéØ DATABASE AGENT RECOMMENDATIONS');
    console.log('=================================');
    console.log('');
    console.log('Current Setup: SQLite ‚úÖ');
    console.log('  üëç Recommended for: Small to medium scale applications');
    console.log('  üëç Already working and tested');
    console.log('  üëç Zero configuration needed');
    console.log('  üëç Perfect for MTG card data volume');
    console.log('');
    console.log('PostgreSQL Option: Available üê≥');
    console.log('  üí™ Better for: High concurrency, advanced features');
    console.log('  üîß Requires: Docker setup, more configuration');
    console.log('  üìä Overkill for: Most MTG investment tracking needs');
    console.log('');
    console.log('üöÄ RECOMMENDATION: Stick with SQLite');
    console.log('   ‚úÖ Production ready as-is');
    console.log('   ‚úÖ DATABASE_URL=file:./data/mtg-investment.db');
    console.log('   ‚úÖ Proceed to Step 3: Deployment Setup');
  }

  async run() {
    const args = process.argv.slice(2);
    
    if (args.includes('--check') || args.length === 0) {
      await this.checkCurrentDatabase();
      this.printRecommendations();
    }
    
    if (args.includes('--postgres-setup')) {
      console.log('üê≥ Setting up PostgreSQL configuration files...');
      this.generateDockerCompose();
      this.generatePostgreSQLInit();
      console.log('');
      console.log('üìã Next steps for PostgreSQL:');
      console.log('   1. docker-compose up -d postgres');
      console.log('   2. Set DATABASE_URL=postgresql://postgres:secure_password_change_this@localhost:5432/mtg_investment');
      console.log('   3. Test connection: node scripts/database-config.js --test-postgres');
    }
    
    if (args.includes('--test-postgres')) {
      const connectionString = process.env.DATABASE_URL || 'postgresql://postgres:secure_password_change_this@localhost:5432/mtg_investment';
      await this.testPostgreSQLConnection(connectionString);
    }
  }
}

// Run if called directly
if (require.main === module) {
  const tool = new DatabaseConfigurationTool();
  tool.run().catch(console.error);
}

module.exports = DatabaseConfigurationTool;
